const { expect } = require('chai')
const {
  insertion,
  binaryToString,
  flipBitToWin,
} = require('./problems')

describe('Chapter 5: Bit Manipulation -', () => {
  // 5.1 insertion
  describe('insertion', () => {
    it('inserts bits M into bits N starting at bit j and ending at bit i', () => {
      let N = 10000000000
      let M = 10011
      let i = 2
      let j = 6
      expect(insertion(N, M, i, j)).to.be.equal(10001001100)
      i = 1
      j = 5
      expect(insertion(N, M, i, j)).to.be.equal(10000100110)
    })

    it('overwrites bit locations in N with the respective M values', () => {
      let N = 11111111111
      let M = 10011
      let i = 2
      let j = 6
      expect(insertion(N, M, i, j)).to.be.equal(11111001111)
    })
  })

  // 5.2 binaryToString
  describe('binaryToString', () => {
    it('returns the binary representation for a given float between 0 and 1 with a valid representation', () => {
      expect(binaryToString(0.625)).to.be.equal('0.101')
      expect(binaryToString(0.5)).to.be.equal('0.1')
      expect(binaryToString(0.875)).to.be.equal('0.111')
    })

    it('returns an error if a valid binary represenation does not exist for a given flaot', () => {
      expect(() => { binaryToString(0.1) }).to.throw()
      expect(() => { binaryToString(0.2) }).to.throw()
      expect(() => { binaryToString(0.3) }).to.throw()
    })
  })

  // 5.3 flipBitToWin
  describe('flipBitToWin', () => {
    it('returns the longest sequence of 1\'s that can be generated by flipping one bit from 0 to 1', () => {
      expect(flipBitToWin(11011101111)).to.be.equal(8)
      expect(flipBitToWin(00110111100)).to.be.equal(7)
    })
  })
})
